import pandas as pd
import numpy as np
from gplearn.genetic import SymbolicClassifier
from gplearn.functions import make_function
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

# Sample data (same as before)
data = {
    'action': ['Buy', 'Sell', 'Buy', 'Sell', 'Buy', 'Sell', 'Buy', 'Sell'],
    'qty': [100, -50, -75, 200, -120, 80, 50, -90]
}
df = pd.DataFrame(data)
df['true_action'] = np.where(df['qty'] < 0, 
                           np.where(df['action'] == 'Buy', 'Sell', 'Buy'),
                           df['action'])

# Prepare data for model (same as before)
le = LabelEncoder()
df['action_code'] = le.fit_transform(df['action'])
X = df[['action_code', 'qty']]
y = le.fit_transform(df['true_action'])

# Split data
X_train, _, y_train, _ = train_test_split(X, y, test_size=0.2, random_state=42)

# Custom functions for gplearn
def is_negative(x):
    return np.where(x < 0, 1, 0)

def flip(x):
    return 1 - x

def if_then_else(cond, x, y):
    return np.where(cond, x, y)

is_neg = make_function(function=is_negative, name='is_neg', arity=1)
flip_func = make_function(function=flip, name='flip', arity=1)
ite = make_function(function=if_then_else, name='ite', arity=3)

# Create and train gplearn model
est_gp = SymbolicClassifier(
    population_size=1000,
    generations=50,  # Increase generations for better convergence
    stopping_criteria=0.0,
    p_crossover=0.7,
    p_subtree_mutation=0.1,
    p_hoist_mutation=0.05,
    p_point_mutation=0.1,
    max_samples=0.9,
    verbose=1,
    parsimony_coefficient=0.01,  # Prefer simpler models
    random_state=42,
    function_set=(
        'add', 'sub', 'mul', 'div',  # Basic arithmetic
        is_neg, flip_func, ite       # Our custom functions
    )
)

est_gp.fit(X_train, y_train)

# Print the best program
print("Best program found by gplearn:")
print(est_gp._program)
print("\n")

# Helper function to make the rule more readable
def make_readable(node, feature_names):
    if isinstance(node, str):
        if node.startswith('X'):
            idx = int(node[1:])
            return feature_names[idx]
        else:
            return node
    elif isinstance(node, (int, float)):
        return f"{node}"
    else:
        if not hasattr(node, '__iter__'):
            # Some nodes might be function objects
            return str(node)
        
        name, *args = node
        name = str(name)  # Convert function object to string if needed
        
        if name == 'ite':
            cond, x, y = [make_readable(arg, feature_names) for arg in args]
            return f"if {cond} then {x} else {y}"
        elif name == 'is_neg':
            arg = make_readable(args[0], feature_names)
            return f"{arg} < 0"
        elif name == 'flip':
            arg = make_readable(args[0], feature_names)
            return f"NOT {arg}"
        else:
            args = [make_readable(arg, feature_names) for arg in args]
            return f"{name}({', '.join(args)})"

# Convert the best program to a readable format
feature_names = ['action', 'qty']
readable_rule = make_readable(est_gp._program.program, feature_names)
print("Rule in Plain English:")
print(readable_rule)
print("\n")

# Test the rule on some examples
examples = [
    {'action': 'Buy', 'qty': -50},
    {'action': 'Sell', 'qty': -75},
    {'action': 'Buy', 'qty': 100},
    {'action': 'Sell', 'qty': 200},
    {'action': 'Buy', 'qty': -10},
    {'action': 'Sell', 'qty': -5}
]

for example in examples:
    action = example['action']
    qty = example['qty']
    
    new_data = pd.DataFrame([example])
    new_data['action_code'] = le.transform(new_data['action'])
    X_new = new_data[['action_code', 'qty']]
    y_pred = est_gp.predict(X_new)
    predicted_action = le.inverse_transform(y_pred)[0]
    
    print(f"Original: {action} {qty} -> Predicted: {predicted_action}")
